
USING: kernel sequences arrays vectors namespaces math strings
    combinators continuations ;

IN: prolog

SYMBOL: pldb
SYMBOL: plchoice

: 2dupd ( x y z -- x y x y z ) >r 2dup r> ;

: init-pl ( -- )
    2 V{ } clone <array> pldb set 
    V{ } clone plchoice set ;

: reset-choice ( -- ) V{ } clone plchoice set ;
: remove-choice ( -- ) plchoice get pop drop ;

: facts ( -- vector ) 0 pldb get nth ;
: rules ( -- vector ) 1 pldb get nth ;
: fact ( n -- fact ) dup facts length >= [ drop "No." ] [ facts nth ] if ;
: rule ( n -- rule ) dup rules length >= [ drop "No." ] [ rules nth ] if ;

: var? ( pl-obj -- ? ) 
    dup string? [ 0 swap nth dup CHAR: A >= swap CHAR: Z <= and ] [ drop f ] if ;
: const? ( pl-obj -- ? ) var? not ;

: check-atom ( string -- ? ) const? ;

: check-fact ( list -- list ? )
    dup t
    [ { 
        { [ dup string? ] [ check-atom ] }
        { [ number? ] [ t ] }
        { [ t ] [ f ] }
    } cond and ] reduce ;

: store-fact ( name fact -- ) 2array facts dup length swap set-nth ;

: add-fact ( name fact -- )
    check-fact [ store-fact ] [ drop " not valid" append print ] if ;

: add-choice ( continuation -- ) plchoice get push ;

: last-choice ( -- ) plchoice get pop continue ;

: extract-fact ( fact-entry -- fact ) dup string? [ 1 swap nth ] unless ;

: (lookup-fact) ( name num -- fact )
    dup fact dup "No." = >r 0 swap nth swapd dupd = swapd r> or 
    [ dup fact [ add-choice ] callcc0 ] when
    dup number? [ 1+ (lookup-fact) ] [ 2nip extract-fact ] if ;

: check-arity ( pattern fact -- pattern fact ? ) 2dup [ length ] 2apply = ;

: check-elements ( pattern fact -- ? ) 
    t [ over var? [ 2drop t ] [ = ] if and ] 2reduce ;

: match-pattern ( pattern fact -- ? )
    check-arity [ check-elements ] [ 2drop f ] if ;

: good-result? ( pattern fact -- pattern fact ? )
    2dup dup "No." = [ 2drop t ] [ match-pattern ] if ;

: lookup-fact ( name pattern -- fact ) 
    swap 0 (lookup-fact) good-result? [ nip ] [ last-choice ] if ;

: store-rule ( name pattern body -- ) 3array rules dup length swap set-nth ;

: add-rule ( name pattern body -- ) store-rule ;

: (lookup-rule) ( name num -- rule )
    dup rule dup "No." = >r 0 swap nth swapd dupd = swapd r> or 
    [ dup rule [ add-choice ] callcc0 ] when
    dup number? [ 1+ (lookup-rule) ] [ 2nip ] if ;

: add-bindings ( pat-d pat-f binds -- binds )
    [ over var? over const? or 
        [ 2drop ] [ swap 2array swap dup >r push r> ] if 
    ] 2reduce ;

: init-binds ( pat-d pat-f -- binds ) V{ } clone add-bindings >alist ;

: deep-replace ( binds seq -- binds seq' )
    [ dup var? [ over 2dup key? [ at ] [ drop ] if ]
        [ dup sequence? [ dupd deep-replace nip ] when ] if 
    ] map ;

: backtrace? ( result -- )
    dup "No." = [ remove-choice last-choice ] [ [ last-choice ] unless* ] if ;

: resolve-rule ( binds rules -- binds )
    [ deep-replace >quotation call backtrace? ] each ;
