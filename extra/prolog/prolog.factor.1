
USING: kernel sequences arrays vectors namespaces math strings
    combinators continuations ;

IN: prolog

SYMBOL: pldb
SYMBOL: plchoice

: 2dupd ( x y z -- x y x y z ) >r 2dup r> ;

: init-pl ( -- )
    2 V{ } clone <array> pldb set 
    V{ } clone plchoice set ;

: reset-choice ( -- ) V{ } clone plchoice set ;
: remove-choice ( -- ) plchoice get pop drop ;

: facts ( -- vector ) 0 pldb get nth ;
: rules ( -- vector ) 1 pldb get nth ;
: fact ( n -- fact ) dup facts length >= [ drop "No." ] [ facts nth ] if ;
: rule ( n -- rule ) dup rules length >= [ drop "No." ] [ rules nth ] if ;

: const? ( number/string -- ? ) 
    dup number? [ nip ]
    [ 0 swap nth dup CHAR: a >= swap CHAR: z <= and ] if* ;
: var? ( number/string -- ? ) const? not ;
: check-atom ( string -- ? ) const? ;

: check-fact ( list -- list ? )
    dup t
    [ { 
        { [ dup string? ] [ check-atom ] }
        { [ number? ] [ t ] }
        { [ t ] [ f ] }
    } cond and ] reduce ;

: store-fact ( name fact -- ) 2array facts dup length swap set-nth ;

: add-fact ( name fact -- )
    check-fact [ store-fact ] [ drop " not valid" append print ] if ;

: add-choice ( continuation -- ) 
    dup continuation? [ plchoice get push ] [ drop ] if ;

: last-choice ( -- ) plchoice get pop continue ;

: extract-fact ( fact-entry -- fact ) dup string? [ 1 swap nth ] unless ;

: (lookup-fact) ( name num -- fact )
    dup fact dup "No." = >r 0 swap nth swapd dupd = swapd r> or 
    [ dup fact [ ] callcc0 add-choice ] when
    dup number? [ 1+ (lookup-fact) ] [ 2nip extract-fact ] if ;

: check-arity ( pattern fact -- pattern fact ? ) 2dup [ length ] 2apply = ;

: (check-elements) ( fact pattern n ? -- ? )
    >r dup zero?
    [ 3drop r> ]
    [ 1 - dup -rot swap dup >r nth dup var?
        [ drop r> swap r> t and (check-elements) ]
        [ >r dupd dup >r swap nth r> r> swap >r = r> swap r> swap r> and swapd
            [ (check-elements) ] [ 3drop f ] if*
        ] if
    ] if ;

: check-elements ( pattern fact -- ? ) swap dup length t (check-elements) ;

: match-pattern ( pattern fact -- ? )
    check-arity [ check-elements ] [ 2drop f ] if ;

: good-result? ( pattern fact -- pattern fact ? )
    2dup dup "No." = [ 2drop t ] [ match-pattern ] if ;

: lookup-fact ( name pattern -- fact ) 
    swap 0 (lookup-fact) good-result? [ nip ] [ last-choice ] if ;

: store-rule ( name pattern body -- ) 3array rules dup length swap set-nth ;

: add-rule ( name pattern body -- ) store-rule ;

: (lookup-rule) ( name num -- rule )
    dup rule dup "No." = >r 0 swap nth swapd dupd = swapd r> or 
    [ dup rule [ ] callcc0 add-choice ] when
    dup number? [ 1+ (lookup-rule) ] [ 2nip ] if ;

! : (init-binds) ( pat-d pat-f binds limit pos -- pat-d pat-f binds limit pos )
!   -rot >r >r dup >r [ swap nth ] curry 2dupd 2apply

! : init-binds ( pat-d pat-f -- pat-d binds )
    
